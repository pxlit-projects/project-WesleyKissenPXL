{"ast":null,"code":"import { TestBed } from '@angular/core/testing';\nimport { ReviewService } from './';\nimport { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\nimport { AuthService } from './auth-service.service';\nimport { environment } from 'environments/environment.development';\nimport { ReviewablePost } from '@models/review.models';\n// Mock AuthService\nclass MockAuthService {\n  getRole() {\n    return 'gebruiker'; // mock role to simulate a standard user\n  }\n}\ndescribe('ReviewService', () => {\n  let service;\n  let httpMock;\n  let authService;\n  const apiUrl = environment.reviewApiUrl;\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      providers: [ReviewService, {\n        provide: AuthService,\n        useClass: MockAuthService\n      }]\n    });\n    service = TestBed.inject(ReviewService);\n    httpMock = TestBed.inject(HttpTestingController);\n    authService = TestBed.inject(AuthService); // Typecasting to MockAuthService\n  });\n  afterEach(() => {\n    httpMock.verify();\n  });\n  describe('getPostsWaitingForApproval', () => {\n    it('should fetch all posts waiting for approval and return them', () => {\n      const mockPosts = [new ReviewablePost('1', 'Post 1', 'Content 1', 'Author 1', new Date('2025-01-16T10:00:00'), 'WAITING_FOR_APPROVAL'), new ReviewablePost('2', 'Post 2', 'Content 2', 'Author 2', new Date('2025-01-16T10:00:00'), 'WAITING_FOR_APPROVAL')];\n      service.getPostsWaitingForApproval().subscribe(posts => {\n        expect(posts.length).toBe(2);\n        expect(posts).toEqual(mockPosts);\n      });\n      const req = httpMock.expectOne(`${apiUrl}/getAllReviewablePosts`);\n      expect(req.request.method).toBe('GET');\n      req.flush(mockPosts);\n    });\n    it('should handle error when fetching posts fails', () => {\n      service.getPostsWaitingForApproval().subscribe({\n        next: () => fail('should have failed with an error'),\n        error: error => {\n          expect(error.status).toBe(500);\n        }\n      });\n      const req = httpMock.expectOne(`${apiUrl}/getAllReviewablePosts`);\n      req.flush('Error', {\n        status: 500,\n        statusText: 'Server Error'\n      });\n    });\n  });\n  describe('publishPost', () => {\n    it('should publish a post successfully', () => {\n      const reviewId = '1';\n      service.publishPost(reviewId).subscribe(response => {\n        expect(response).toBeTruthy();\n      });\n      const req = httpMock.expectOne(`${apiUrl}/${reviewId}/publishReviewPost`);\n      expect(req.request.method).toBe('PUT');\n      req.flush({});\n    });\n    it('should handle error when publishing a post fails', () => {\n      const reviewId = '1';\n      service.publishPost(reviewId).subscribe({\n        next: () => fail('should have failed with an error'),\n        error: error => {\n          expect(error.status).toBe(400);\n        }\n      });\n      const req = httpMock.expectOne(`${apiUrl}/${reviewId}/publishReviewPost`);\n      req.flush('Error', {\n        status: 400,\n        statusText: 'Bad Request'\n      });\n    });\n  });\n  describe('rejectPost', () => {\n    it('should reject a post successfully with rejection reason', () => {\n      const reviewId = '1';\n      const reviewMessage = {\n        message: 'Rejecting this post.'\n      };\n      service.rejectPost(reviewId, reviewMessage).subscribe(response => {\n        expect(response).toBeTruthy();\n      });\n      const req = httpMock.expectOne(`${apiUrl}/${reviewId}/reject`);\n      expect(req.request.method).toBe('PUT');\n      expect(req.request.body).toEqual(reviewMessage);\n      req.flush({});\n    });\n    it('should reject a post successfully without rejection reason', () => {\n      const reviewId = '2';\n      const reviewMessage = {}; // Empty message object\n      service.rejectPost(reviewId, reviewMessage).subscribe(response => {\n        expect(response).toBeTruthy();\n      });\n      const req = httpMock.expectOne(`${apiUrl}/${reviewId}/reject`);\n      expect(req.request.method).toBe('PUT');\n      expect(req.request.body).toEqual(reviewMessage);\n      req.flush({});\n    });\n    it('should handle error when rejecting a post fails', () => {\n      const reviewId = '1';\n      const reviewMessage = {\n        message: 'Rejecting this post.'\n      };\n      service.rejectPost(reviewId, reviewMessage).subscribe({\n        next: () => fail('should have failed with an error'),\n        error: error => {\n          expect(error.status).toBe(400);\n        }\n      });\n      const req = httpMock.expectOne(`${apiUrl}/${reviewId}/reject`);\n      req.flush('Error', {\n        status: 400,\n        statusText: 'Bad Request'\n      });\n    });\n  });\n});","map":{"version":3,"names":["TestBed","ReviewService","HttpClientTestingModule","HttpTestingController","AuthService","environment","ReviewablePost","MockAuthService","getRole","describe","service","httpMock","authService","apiUrl","reviewApiUrl","beforeEach","configureTestingModule","imports","providers","provide","useClass","inject","afterEach","verify","it","mockPosts","Date","getPostsWaitingForApproval","subscribe","posts","expect","length","toBe","toEqual","req","expectOne","request","method","flush","next","fail","error","status","statusText","reviewId","publishPost","response","toBeTruthy","reviewMessage","message","rejectPost","body"],"sources":["C:\\School\\PXL\\2024-2025\\Fullstack Java\\Opdracht\\Code\\project-WesleyKissenPXL\\frontend-web\\src\\app\\shared\\services\\review-service.service.spec.ts"],"sourcesContent":["import { TestBed } from '@angular/core/testing';\r\nimport { ReviewService } from './';\r\nimport { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\r\nimport { AuthService } from './auth-service.service';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { environment } from 'environments/environment.development';\r\nimport { ReviewablePost } from '@models/review.models';\r\nimport { of } from 'rxjs';\r\n\r\n// Mock AuthService\r\nclass MockAuthService {\r\n  getRole() {\r\n    return 'gebruiker'; // mock role to simulate a standard user\r\n  }\r\n}\r\n\r\ndescribe('ReviewService', () => {\r\n  let service: ReviewService;\r\n  let httpMock: HttpTestingController;\r\n  let authService: MockAuthService;\r\n  const apiUrl = environment.reviewApiUrl;\r\n\r\n  beforeEach(() => {\r\n    TestBed.configureTestingModule({\r\n      imports: [HttpClientTestingModule],\r\n      providers: [\r\n        ReviewService,\r\n        { provide: AuthService, useClass: MockAuthService },\r\n      ],\r\n    });\r\n\r\n    service = TestBed.inject(ReviewService);\r\n    httpMock = TestBed.inject(HttpTestingController);\r\n    authService = TestBed.inject(AuthService) as any; // Typecasting to MockAuthService\r\n  });\r\n\r\n  afterEach(() => {\r\n    httpMock.verify();\r\n  });\r\n\r\n  describe('getPostsWaitingForApproval', () => {\r\n    it('should fetch all posts waiting for approval and return them', () => {\r\n      const mockPosts: ReviewablePost[] = [\r\n        new ReviewablePost(\r\n          '1',\r\n          'Post 1',\r\n          'Content 1',\r\n          'Author 1',\r\n          new Date('2025-01-16T10:00:00'),\r\n          'WAITING_FOR_APPROVAL'\r\n        ),\r\n        new ReviewablePost(\r\n          '2',\r\n          'Post 2',\r\n          'Content 2',\r\n          'Author 2',\r\n          new Date('2025-01-16T10:00:00'),\r\n          'WAITING_FOR_APPROVAL'\r\n        ),\r\n      ];\r\n\r\n      service.getPostsWaitingForApproval().subscribe((posts) => {\r\n        expect(posts.length).toBe(2);\r\n        expect(posts).toEqual(mockPosts);\r\n      });\r\n\r\n      const req = httpMock.expectOne(`${apiUrl}/getAllReviewablePosts`);\r\n      expect(req.request.method).toBe('GET');\r\n      req.flush(mockPosts);\r\n    });\r\n\r\n    it('should handle error when fetching posts fails', () => {\r\n      service.getPostsWaitingForApproval().subscribe({\r\n        next: () => fail('should have failed with an error'),\r\n        error: (error) => {\r\n          expect(error.status).toBe(500);\r\n        },\r\n      });\r\n\r\n      const req = httpMock.expectOne(`${apiUrl}/getAllReviewablePosts`);\r\n      req.flush('Error', { status: 500, statusText: 'Server Error' });\r\n    });\r\n  });\r\n\r\n  describe('publishPost', () => {\r\n    it('should publish a post successfully', () => {\r\n      const reviewId = '1';\r\n\r\n      service.publishPost(reviewId).subscribe((response) => {\r\n        expect(response).toBeTruthy();\r\n      });\r\n\r\n      const req = httpMock.expectOne(`${apiUrl}/${reviewId}/publishReviewPost`);\r\n      expect(req.request.method).toBe('PUT');\r\n      req.flush({});\r\n    });\r\n\r\n    it('should handle error when publishing a post fails', () => {\r\n      const reviewId = '1';\r\n\r\n      service.publishPost(reviewId).subscribe({\r\n        next: () => fail('should have failed with an error'),\r\n        error: (error) => {\r\n          expect(error.status).toBe(400);\r\n        },\r\n      });\r\n\r\n      const req = httpMock.expectOne(`${apiUrl}/${reviewId}/publishReviewPost`);\r\n      req.flush('Error', { status: 400, statusText: 'Bad Request' });\r\n    });\r\n  });\r\n\r\n  describe('rejectPost', () => {\r\n    it('should reject a post successfully with rejection reason', () => {\r\n      const reviewId = '1';\r\n      const reviewMessage = { message: 'Rejecting this post.' };\r\n\r\n      service.rejectPost(reviewId, reviewMessage).subscribe((response) => {\r\n        expect(response).toBeTruthy();\r\n      });\r\n\r\n      const req = httpMock.expectOne(`${apiUrl}/${reviewId}/reject`);\r\n      expect(req.request.method).toBe('PUT');\r\n      expect(req.request.body).toEqual(reviewMessage);\r\n      req.flush({});\r\n    });\r\n\r\n    it('should reject a post successfully without rejection reason', () => {\r\n      const reviewId = '2';\r\n      const reviewMessage = {}; // Empty message object\r\n\r\n      service.rejectPost(reviewId, reviewMessage).subscribe((response) => {\r\n        expect(response).toBeTruthy();\r\n      });\r\n\r\n      const req = httpMock.expectOne(`${apiUrl}/${reviewId}/reject`);\r\n      expect(req.request.method).toBe('PUT');\r\n      expect(req.request.body).toEqual(reviewMessage);\r\n      req.flush({});\r\n    });\r\n\r\n    it('should handle error when rejecting a post fails', () => {\r\n      const reviewId = '1';\r\n      const reviewMessage = { message: 'Rejecting this post.' };\r\n\r\n      service.rejectPost(reviewId, reviewMessage).subscribe({\r\n        next: () => fail('should have failed with an error'),\r\n        error: (error) => {\r\n          expect(error.status).toBe(400);\r\n        },\r\n      });\r\n\r\n      const req = httpMock.expectOne(`${apiUrl}/${reviewId}/reject`);\r\n      req.flush('Error', { status: 400, statusText: 'Bad Request' });\r\n    });\r\n  });\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}