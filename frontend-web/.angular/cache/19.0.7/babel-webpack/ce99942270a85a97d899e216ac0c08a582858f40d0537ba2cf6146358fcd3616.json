{"ast":null,"code":"import _asyncToGenerator from \"C:/School/PXL/2024-2025/Fullstack Java/Opdracht/Code/project-WesleyKissenPXL/frontend-web/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { TestBed } from '@angular/core/testing';\nimport { Router } from '@angular/router';\nimport { of } from 'rxjs';\nimport { HomepageComponent } from './homepage.component';\nimport { AuthService } from '@services/auth-service.service';\nimport { PostService } from '@services/post-service.service';\nimport { CommentService } from '@services/comment-service.service';\ndescribe('HomepageComponent', () => {\n  let component;\n  let fixture;\n  let authService;\n  let postService;\n  let commentService;\n  let router;\n  beforeEach(/*#__PURE__*/_asyncToGenerator(function* () {\n    const authServiceSpy = jasmine.createSpyObj('AuthService', ['getRole', 'getUserName', 'logout']);\n    const postServiceSpy = jasmine.createSpyObj('PostService', ['getPosts', 'filterPosts']);\n    const commentServiceSpy = jasmine.createSpyObj('CommentService', ['getComments', 'addComment', 'updateComment', 'deleteComment']);\n    const routerSpy = jasmine.createSpyObj('Router', ['navigate']);\n    yield TestBed.configureTestingModule({\n      imports: [HomepageComponent],\n      providers: [{\n        provide: AuthService,\n        useValue: authServiceSpy\n      }, {\n        provide: PostService,\n        useValue: postServiceSpy\n      }, {\n        provide: CommentService,\n        useValue: commentServiceSpy\n      }, {\n        provide: Router,\n        useValue: routerSpy\n      }]\n    }).compileComponents();\n    fixture = TestBed.createComponent(HomepageComponent);\n    component = fixture.componentInstance;\n    authService = TestBed.inject(AuthService);\n    postService = TestBed.inject(PostService);\n    commentService = TestBed.inject(CommentService);\n    router = TestBed.inject(Router);\n  }));\n  it('should create the component', () => {\n    expect(component).toBeTruthy();\n  });\n  describe('ngOnInit', () => {\n    it('should load posts and comments, set role and username', () => {\n      const mockPosts = [{\n        id: '1',\n        title: 'Test Post',\n        content: 'Test Content',\n        author: 'Test Author',\n        timeOfCreation: new Date(),\n        status: 'POSTED'\n      }];\n      const mockComments = [{\n        id: '1',\n        postId: '1',\n        comment: 'Test Comment',\n        author: 'Test Author'\n      }];\n      authService.getRole.and.returnValue('hoofdredacteur');\n      authService.getUserName.and.returnValue('testuser');\n      postService.getPosts.and.returnValue(of(mockPosts));\n      commentService.getComments.and.returnValue(of(mockComments));\n      component.ngOnInit();\n      expect(component.comments).toEqual(mockComments);\n      expect(component.role).toBe('hoofdredacteur');\n      expect(component.username).toBe('testuser');\n      expect(component.showerror).toBeTrue();\n    });\n  });\n  //   describe('onSearch', () => {\n  //     it('should handle error when fetching posts', () => {\n  //       postService.filterPosts.and.returnValue(throwError('Error fetching posts'));\n  //       spyOn(console, 'error');\n  //       component.onSearch();\n  //       expect(console.error).toHaveBeenCalledWith('Error fetching posts:', 'Error fetching posts');\n  //     });\n  //   });\n  describe('getCommentsByPostId', () => {\n    it('should return comments for a specific postId', () => {\n      const postId = '1';\n      const commentsForPost = [{\n        id: '1',\n        postId: '1',\n        comment: 'Test Comment',\n        author: 'Test Author'\n      }];\n      component.comments = commentsForPost;\n      const result = component.getCommentsByPostId(postId);\n      expect(result).toEqual(commentsForPost);\n    });\n  });\n  describe('addComment', () => {\n    // it('should add a new comment successfully', () => {\n    //   const postId = '1';\n    //   const newComment = 'New Comment';\n    //   const author = 'testuser';\n    //   component.newComments[postId] = newComment;\n    //   const commentRequest = new CommentRequest(newComment, author);\n    //   const addedComment = { id: '2', postId: postId, comment: newComment, author: author };\n    //   commentService.addComment.and.returnValue(of([addedComment]));\n    //   component.addComment(postId);\n    //   expect(commentService.addComment).toHaveBeenCalledWith(postId, commentRequest);\n    //   expect(component.comments).toContain(addedComment);\n    //   expect(component.newComments[postId]).toBe('');\n    // });\n    // it('should handle error when adding a comment', () => {\n    //   const postId = '1';\n    //   const newComment = 'New Comment';\n    //   component.newComments[postId] = newComment;\n    //   const commentRequest = new CommentRequest(newComment, 'testuser');\n    //   commentService.addComment.and.returnValue(throwError('Error adding comment'));\n    //   spyOn(console, 'error');\n    //   component.addComment(postId);\n    //   expect(console.error).toHaveBeenCalledWith('Error adding comment:', 'Error adding comment');\n    // });\n    it('should not add a comment if content is empty', () => {\n      const postId = '1';\n      component.newComments[postId] = '';\n      // Spy on console.log to check if it's called when comment content is empty\n      spyOn(console, 'log');\n      component.addComment(postId);\n      expect(commentService.addComment).not.toHaveBeenCalled();\n      expect(console.log).toHaveBeenCalledWith('Comment content is empty.');\n    });\n    //   describe('onEditComment', () => {\n    //     it('should edit a comment successfully', () => {\n    //       const comment = { id: '1', postId: '1', comment: 'Test Comment', author: 'Test Author' };\n    //       const updatedCommentContent = 'Updated Comment';\n    //       spyOn(window, 'prompt').and.returnValue(updatedCommentContent);\n    //       const updatedComment = new UpdateCommentRequest(updatedCommentContent);\n    //       commentService.updateComment.and.returnValue(of(comment));\n    //       component.onEditComment(comment);\n    //       expect(commentService.updateComment).toHaveBeenCalledWith(comment.id, updatedComment);\n    //       expect(component.comments[0].comment).toBe(updatedCommentContent);\n    //     });\n    //     it('should handle error when updating a comment', () => {\n    //       const comment = { id: '1', postId: '1', comment: 'Test Comment', author: 'Test Author' };\n    //       const updatedCommentContent = 'Updated Comment';\n    //       spyOn(window, 'prompt').and.returnValue(updatedCommentContent);\n    //       const updatedComment = new UpdateCommentRequest(updatedCommentContent);\n    //       commentService.updateComment.and.returnValue(throwError('Error updating comment'));\n    //       spyOn(console, 'error');\n    //       component.onEditComment(comment);\n    //       expect(console.error).toHaveBeenCalledWith('Error updating comment:', 'Error updating comment');\n    //     });\n    //   });\n    //   describe('onDeleteComment', () => {\n    //     it('should delete a comment successfully', () => {\n    //       const commentId = '1';\n    //       const comment = { id: commentId, postId: '1', comment: 'Test Comment', author: 'Test Author' };\n    //       component.comments = [comment];\n    //       spyOn(window, 'confirm').and.returnValue(true);\n    //       commentService.deleteComment.and.returnValue(of());\n    //       component.onDeleteComment(commentId);\n    //       expect(commentService.deleteComment).toHaveBeenCalledWith(commentId);\n    //       expect(component.comments.length).toBe(0);\n    //     });\n    //     it('should not delete a comment if user cancels', () => {\n    //       const commentId = '1';\n    //       spyOn(window, 'confirm').and.returnValue(false);\n    //       component.onDeleteComment(commentId);\n    //       expect(commentService.deleteComment).not.toHaveBeenCalled();\n    //     });\n    //   });\n    //   describe('onLogout', () => {\n    //     it('should log out and navigate to the home page', () => {\n    //       authService.logout.and.stub();\n    //       component.onLogout();\n    //       expect(authService.logout).toHaveBeenCalled();\n    //       expect(router.navigate).toHaveBeenCalledWith(['']);\n    //     });\n    //   });\n    //   describe('navigation methods', () => {\n    //     it('should navigate to create post page', () => {\n    //       component.CreatePostRedirect();\n    //       expect(router.navigate).toHaveBeenCalledWith(['/posts']);\n    //     });\n    // it('should navigate to concepts page', () => {\n    //   component.GoToPostConcepts();\n    //   expect(router.navigate).toHaveBeenCalledWith(['/concepts']);\n    // });\n    // it('should navigate to waiting approval page', () => {\n    //   component.GoToPostWaitingApprovals();\n    //   expect(router.navigate).toHaveBeenCalledWith(['/waitingapproval']);\n    // });\n    // it('should navigate to notifications page', () => {\n    //   component.GoToNotifications();\n    //   expect(router.navigate).toHaveBeenCalledWith(['/notifications']);\n    // });\n    //});\n  });\n});","map":{"version":3,"names":["TestBed","Router","of","HomepageComponent","AuthService","PostService","CommentService","describe","component","fixture","authService","postService","commentService","router","beforeEach","_asyncToGenerator","authServiceSpy","jasmine","createSpyObj","postServiceSpy","commentServiceSpy","routerSpy","configureTestingModule","imports","providers","provide","useValue","compileComponents","createComponent","componentInstance","inject","it","expect","toBeTruthy","mockPosts","id","title","content","author","timeOfCreation","Date","status","mockComments","postId","comment","getRole","and","returnValue","getUserName","getPosts","getComments","ngOnInit","comments","toEqual","role","toBe","username","showerror","toBeTrue","commentsForPost","result","getCommentsByPostId","newComments","spyOn","console","addComment","not","toHaveBeenCalled","log","toHaveBeenCalledWith"],"sources":["C:\\School\\PXL\\2024-2025\\Fullstack Java\\Opdracht\\Code\\project-WesleyKissenPXL\\frontend-web\\src\\app\\homepage\\homepage.component.spec.ts"],"sourcesContent":["import { ComponentFixture, TestBed } from '@angular/core/testing';\r\nimport { Router } from '@angular/router';\r\nimport { of, throwError } from 'rxjs';\r\nimport { HomepageComponent } from './homepage.component';\r\nimport { AuthService } from '@services/auth-service.service';\r\nimport { PostService } from '@services/post-service.service';\r\nimport { CommentService } from '@services/comment-service.service';\r\nimport { Post } from '@models/post.model';\r\nimport { Comment } from '@models/comment.model';\r\nimport { CommentRequest } from '@models/commentRequest.model';\r\nimport { UpdateCommentRequest } from '@models/updateCommentRequest.model';\r\n\r\ndescribe('HomepageComponent', () => {\r\n  let component: HomepageComponent;\r\n  let fixture: ComponentFixture<HomepageComponent>;\r\n  let authService: jasmine.SpyObj<AuthService>;\r\n  let postService: jasmine.SpyObj<PostService>;\r\n  let commentService: jasmine.SpyObj<CommentService>;\r\n  let router: jasmine.SpyObj<Router>;\r\n\r\n  beforeEach(async () => {\r\n    const authServiceSpy = jasmine.createSpyObj('AuthService', ['getRole', 'getUserName', 'logout']);\r\n    const postServiceSpy = jasmine.createSpyObj('PostService', ['getPosts', 'filterPosts']);\r\n    const commentServiceSpy = jasmine.createSpyObj('CommentService', ['getComments', 'addComment', 'updateComment', 'deleteComment']);\r\n    const routerSpy = jasmine.createSpyObj('Router', ['navigate']);\r\n\r\n    await TestBed.configureTestingModule({\r\n      imports: [HomepageComponent],\r\n      providers: [\r\n        { provide: AuthService, useValue: authServiceSpy },\r\n        { provide: PostService, useValue: postServiceSpy },\r\n        { provide: CommentService, useValue: commentServiceSpy },\r\n        { provide: Router, useValue: routerSpy }\r\n      ]\r\n    }).compileComponents();\r\n\r\n    fixture = TestBed.createComponent(HomepageComponent);\r\n    component = fixture.componentInstance;\r\n    authService = TestBed.inject(AuthService) as jasmine.SpyObj<AuthService>;\r\n    postService = TestBed.inject(PostService) as jasmine.SpyObj<PostService>;\r\n    commentService = TestBed.inject(CommentService) as jasmine.SpyObj<CommentService>;\r\n    router = TestBed.inject(Router) as jasmine.SpyObj<Router>;\r\n  });\r\n\r\n  it('should create the component', () => {\r\n    expect(component).toBeTruthy();\r\n  });\r\n\r\n  describe('ngOnInit', () => {\r\n    it('should load posts and comments, set role and username', () => {\r\n      const mockPosts: Post[] = [{ id: '1', title: 'Test Post', content: 'Test Content', author: 'Test Author', timeOfCreation: new Date(), status: 'POSTED'}];\r\n      const mockComments: Comment[] = [{ id: '1', postId: '1', comment: 'Test Comment', author: 'Test Author' }];\r\n      authService.getRole.and.returnValue('hoofdredacteur');\r\n      authService.getUserName.and.returnValue('testuser');\r\n      postService.getPosts.and.returnValue(of(mockPosts));\r\n      commentService.getComments.and.returnValue(of(mockComments));\r\n\r\n      component.ngOnInit();\r\n\r\n      expect(component.comments).toEqual(mockComments);\r\n      expect(component.role).toBe('hoofdredacteur');\r\n      expect(component.username).toBe('testuser');\r\n      expect(component.showerror).toBeTrue();\r\n    });\r\n  });\r\n\r\n//   describe('onSearch', () => {\r\n\r\n//     it('should handle error when fetching posts', () => {\r\n//       postService.filterPosts.and.returnValue(throwError('Error fetching posts'));\r\n//       spyOn(console, 'error');\r\n\r\n//       component.onSearch();\r\n\r\n//       expect(console.error).toHaveBeenCalledWith('Error fetching posts:', 'Error fetching posts');\r\n//     });\r\n//   });\r\n\r\n  describe('getCommentsByPostId', () => {\r\n    it('should return comments for a specific postId', () => {\r\n      const postId = '1';\r\n      const commentsForPost = [{ id: '1', postId: '1', comment: 'Test Comment', author: 'Test Author' }];\r\n      component.comments = commentsForPost;\r\n\r\n      const result = component.getCommentsByPostId(postId);\r\n\r\n      expect(result).toEqual(commentsForPost);\r\n    });\r\n  });\r\n\r\n  describe('addComment', () => {\r\n    // it('should add a new comment successfully', () => {\r\n    //   const postId = '1';\r\n    //   const newComment = 'New Comment';\r\n    //   const author = 'testuser';\r\n    //   component.newComments[postId] = newComment;\r\n    //   const commentRequest = new CommentRequest(newComment, author);\r\n    //   const addedComment = { id: '2', postId: postId, comment: newComment, author: author };\r\n\r\n    //   commentService.addComment.and.returnValue(of([addedComment]));\r\n\r\n    //   component.addComment(postId);\r\n\r\n    //   expect(commentService.addComment).toHaveBeenCalledWith(postId, commentRequest);\r\n    //   expect(component.comments).toContain(addedComment);\r\n    //   expect(component.newComments[postId]).toBe('');\r\n    // });\r\n\r\n    // it('should handle error when adding a comment', () => {\r\n    //   const postId = '1';\r\n    //   const newComment = 'New Comment';\r\n    //   component.newComments[postId] = newComment;\r\n    //   const commentRequest = new CommentRequest(newComment, 'testuser');\r\n\r\n    //   commentService.addComment.and.returnValue(throwError('Error adding comment'));\r\n    //   spyOn(console, 'error');\r\n\r\n    //   component.addComment(postId);\r\n\r\n    //   expect(console.error).toHaveBeenCalledWith('Error adding comment:', 'Error adding comment');\r\n    // });\r\n\r\n    it('should not add a comment if content is empty', () => {\r\n        const postId = '1';\r\n        component.newComments[postId] = '';\r\n        \r\n        // Spy on console.log to check if it's called when comment content is empty\r\n        spyOn(console, 'log');\r\n      \r\n        component.addComment(postId);\r\n      \r\n        expect(commentService.addComment).not.toHaveBeenCalled();\r\n        expect(console.log).toHaveBeenCalledWith('Comment content is empty.');\r\n});\r\n\r\n//   describe('onEditComment', () => {\r\n//     it('should edit a comment successfully', () => {\r\n//       const comment = { id: '1', postId: '1', comment: 'Test Comment', author: 'Test Author' };\r\n//       const updatedCommentContent = 'Updated Comment';\r\n//       spyOn(window, 'prompt').and.returnValue(updatedCommentContent);\r\n//       const updatedComment = new UpdateCommentRequest(updatedCommentContent);\r\n\r\n//       commentService.updateComment.and.returnValue(of(comment));\r\n\r\n//       component.onEditComment(comment);\r\n\r\n//       expect(commentService.updateComment).toHaveBeenCalledWith(comment.id, updatedComment);\r\n//       expect(component.comments[0].comment).toBe(updatedCommentContent);\r\n//     });\r\n\r\n//     it('should handle error when updating a comment', () => {\r\n//       const comment = { id: '1', postId: '1', comment: 'Test Comment', author: 'Test Author' };\r\n//       const updatedCommentContent = 'Updated Comment';\r\n//       spyOn(window, 'prompt').and.returnValue(updatedCommentContent);\r\n//       const updatedComment = new UpdateCommentRequest(updatedCommentContent);\r\n\r\n//       commentService.updateComment.and.returnValue(throwError('Error updating comment'));\r\n//       spyOn(console, 'error');\r\n\r\n//       component.onEditComment(comment);\r\n\r\n//       expect(console.error).toHaveBeenCalledWith('Error updating comment:', 'Error updating comment');\r\n//     });\r\n//   });\r\n\r\n//   describe('onDeleteComment', () => {\r\n//     it('should delete a comment successfully', () => {\r\n//       const commentId = '1';\r\n//       const comment = { id: commentId, postId: '1', comment: 'Test Comment', author: 'Test Author' };\r\n//       component.comments = [comment];\r\n//       spyOn(window, 'confirm').and.returnValue(true);\r\n\r\n//       commentService.deleteComment.and.returnValue(of());\r\n\r\n//       component.onDeleteComment(commentId);\r\n\r\n//       expect(commentService.deleteComment).toHaveBeenCalledWith(commentId);\r\n//       expect(component.comments.length).toBe(0);\r\n//     });\r\n\r\n//     it('should not delete a comment if user cancels', () => {\r\n//       const commentId = '1';\r\n//       spyOn(window, 'confirm').and.returnValue(false);\r\n\r\n//       component.onDeleteComment(commentId);\r\n\r\n//       expect(commentService.deleteComment).not.toHaveBeenCalled();\r\n//     });\r\n//   });\r\n\r\n//   describe('onLogout', () => {\r\n//     it('should log out and navigate to the home page', () => {\r\n//       authService.logout.and.stub();\r\n\r\n//       component.onLogout();\r\n\r\n//       expect(authService.logout).toHaveBeenCalled();\r\n//       expect(router.navigate).toHaveBeenCalledWith(['']);\r\n//     });\r\n//   });\r\n\r\n//   describe('navigation methods', () => {\r\n//     it('should navigate to create post page', () => {\r\n//       component.CreatePostRedirect();\r\n\r\n//       expect(router.navigate).toHaveBeenCalledWith(['/posts']);\r\n//     });\r\n\r\n    // it('should navigate to concepts page', () => {\r\n    //   component.GoToPostConcepts();\r\n\r\n    //   expect(router.navigate).toHaveBeenCalledWith(['/concepts']);\r\n    // });\r\n\r\n    // it('should navigate to waiting approval page', () => {\r\n    //   component.GoToPostWaitingApprovals();\r\n\r\n    //   expect(router.navigate).toHaveBeenCalledWith(['/waitingapproval']);\r\n    // });\r\n\r\n    // it('should navigate to notifications page', () => {\r\n    //   component.GoToNotifications();\r\n\r\n    //   expect(router.navigate).toHaveBeenCalledWith(['/notifications']);\r\n    // });\r\n  //});\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}